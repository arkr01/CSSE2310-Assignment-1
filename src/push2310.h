/* Program exit codes */
typedef enum {
    EXIT_NORMAL = 0,
    EXIT_ARGS = 1,
    EXIT_PLAYER_TYPE = 2,
    EXIT_FILE_READ = 3,
    EXIT_FILE_CONTENTS = 4,
    EXIT_EOF = 5,
    EXIT_FULL_BOARD = 6
} ExitCodes;

/* Game Representation - Stores all information
 * about the board and the players. */
typedef struct {
    char** board;
    char playerTypeO;
    char playerTypeX;
    char currentPlayer;
    long int rows;
    long int columns;
    long int rowMove;
    long int columnMove;
} Game;

/* To understand the internal game representation of the board, consider the
 * following example:
 *   0.0.0.0.
 * 0.1.2O1.2.0.
 * 0.3.2.4.5X0.
 * 0.4.1.2.6.0.
 *   7.7.9.9.  
 * The game board is represented via a dynamic 2D char** array in which each
 * element is a char. Hence, each character in the game board is individually
 * indexed (as opposed to the user's end, in which only the empty cells (i.e.
 * the dots) can be accessed. Hence, as indexing commences from 0, and each
 * row begins either with 2 blank spaces (i.e. the first and last row), or a
 * 0, each even index of the columns refers to a score value, and each odd
 * index refers to either an X, an O, or a . (empty cell). For example, the
 * move that player X has made, in the game would correspond to 2 4. However,
 * as each character is indexed in the internal game representation, the move
 * 2 4 would correspond to index [2][9], to account for each character.
 * Similarly, player O's move, to the user, would correspond to move 1 2, but
 * in the internal game representation, the array index would be [1][5] */

/* Based on the above explanation, consider the following. By definition, an
 * odd integer n is equal to 2 * k + 1 for some integer k, and this can be
 * seen in the above examples (here, k is the column number). */
#define MOVE_INDEX 2 * game->columnMove + 1

/* As the definition of an odd number is n = 2 * k + 1 for integers n and k,
 * in some cases we may like to find k. In this case,
 * c = 2 * game->columnMove + 1, and we must find game->columnMove. c is odd
 * by definition hence the division below does not cause issues with integer
 * division. */
#define COLUMN_MOVE (c - 1) / 2 

/* As each cell contains both a score value and either an empty dot, or a
 * player's stone, there are (2 * game->columns) columns in the game under the
 * internal game representation. Hence, as we index from 0, the final interior
 * playing cells (wheter an empty dot or a player's stone), in each row are
 * given by the the following. */
#define LAST_INTERIOR_CELL_COLUMN 2 * game->columns - 3

/* By the same logic above, the column index immediately before the above
 * would correspond to the score of the last interior cell column.
 * Factorising this expression leads to the following. */
#define SCORE_COLUMN_OF_LAST_INTERIOR_CELL 2 * (game->columns - 2)

/* By the same logic above, the column index immediately before the above
 * would correspond to the playing cell of the second last interior cell
 * column. Expanding this expression leads to the following. */
#define SECOND_LAST_INTERIOR_CELL_COLUMN 2 * game->columns - 5

/* By the same logic as LAST_INTERIOR_CELL_COLUMN, the cells at
 * 2 * game->columns - 2 are the score values of the final column. This can be
 * represented by the following. */
#define SCORE_COLUMN_OF_LAST_CELL 2 * (game->columns - 1)

/* By the same logic as SCORE_COLUMN_OF_LAST_CELL, the cells at
 * 2 * game->columns - 1 represent the final column of the game board. */
#define LAST_CELL_COLUMN 2 * game->columns - 1

/* Takes in the argument count, the argument values, the current exit status,
 * and the game representation. This function fprints to stderr and returns
 * EXIT_ARGS if an incorrect number of args is found. Otherwise, this function
 * validates the player types that were input when starting the game, fprints
 * to stderr and returns EXIT_PLAYER_TYPE if invalid player type(s) are found,
 * and returns EXIT_NORMAL if the player types entered are both valid. */
int argc_player_types_handler(int argc, char** argv, ExitCodes* exitStatus,
	Game* game);

/* Takes in the save file, the game representation, the current exit status,
 * the line from the save file that presents the board dimensions, the errors
 * generated by strtol calls to obtain the specific number of rows and
 * columns, and a flag to check for EOF found in invalid places (e.g. when
 * reading in a 3x3 board and EOF is triggered after row 1). If opening the
 * file fails, this function fprints to stderr and returns EXIT_FILE_READ.
 * Otherwise, this function partially validates and sets up the information
 * necessary for the board (i.e. board dimensions, first/current player)
 * and returns EXIT_NORMAL. If invalid contents are found, these are handled
 * in file_contents_error_handler. */
int file_setup(FILE* gameFile, Game* game, ExitCodes* exitStatus,
	char** rowsAndColumns, char** rowErrors,
	char** columnErrors, int* eofFlag);

/* Takes in the game representation, the errors generated by strtol calls to
 * obtain the row and columns from the save file, and the current exit status.
 * This function validates file contents of specified save file, specifically,
 * it validates the board dimensions, the current player, and board cell
 * values. It also checks that the file dimensions match with the actual board
 * dimensions. This function returns EXIT_FILE_CONTENTS and fprints to stderr
 * if invalid file contents are found, returns EXIT_NORMAL otherwise. */
int file_contents_error_handler(Game* game, char* rowErrors,
	char* columnErrors, ExitCodes* exitStatus);

/* Takes in loop iterators r and c, the game representation, and counters for
 * the number of zeros in the board interior, and for the number of invalid
 * characters in the board interior. The function increments the counters if
 * need be. */
void validate_interior(int r, int c, Game* game, int* interiorZeroCounter,
	int* invalidCharCounter);

/* Takes in loop iterators r and c, the game representation, and counters for
 * the number of zeros in the board border, and for the number of invalid
 * characters in the board border. The function increments the counters if
 * need be. */
void validate_border(int r, int c, Game* game, int* borderZeroCounter,
	int* invalidCharCounter);

/* Takes in a line of input and counts the number of spaces in said line.
 * Returns the number of spaces. */
int space_counter(char** input);

/* Takes in a file stream and reads in a line of input, also takes in the
 * maximum length of the line to be read, as well as a flag to check for EOF
 * found in invalid places (e.g. when reading in a 3x3 board and EOF is
 * triggered after row 1). Returns the line read. Note that this line is
 * malloc'd. However, if (valid) EOF is detected then this line is free'd in
 * the function and a sentinel value 'test_EOF' is instead returned. If
 * invalid EOF is detected, update eofFlag to the value of 1 and return the
 * line read as per normal. */
char* read_line(FILE* file, size_t size, int* eofFlag);

/* Takes in the game representation, the save file, and a flag to check for
 * EOF found in invalid places (e.g. when reading in a 3x3 board and EOF is
 * triggered after row 1). This function initialises the game board by
 * creating an empty game board based on the file contents.
 * These contents should be validated after calling this function. */
void init_board(Game* game, FILE* gameFile, int* eofFlag);

/* Takes in the game representation and checks if the game board interior is
 * full. If so, returns EXIT_FULL_BOARD, otherwise returns EXIT_NORMAL. */
int check_board_full(Game* game);

/* Takes in the game representation, the current exit status, the line from
 * the save file that showed the dimensions of the board, the save file
 * itself, and a flag to check for EOF found in invalid places (e.g. when
 * processing a valid human move that ends in EOF). This function forms as the
 * entry point for the game. It handles EOF on stdin when input required, the
 * results of all types of game moves (i.e. type 0, type 1, and human), and
 * all free's and file closing in case of an abrupt termination of the game */
void play_game(Game* game, ExitCodes* exitStatus, char* rowsAndColumns,
	FILE* gameFile, int* eofFlag);

/* Takes in the human move made, the strtol errors generated by calls to 
 * obtain the specific row and column moves, the game representation, the
 * current exit status, and a flag to check for EOF found in invalid places
 * (e.g. when processing a valid human move that ends in EOF). Entry point for
 * handling the execution of Type 0, Type 1, and Human game moves, as well as
 * saving. */
void game_move(char** move, char** rowMoveErrors, char** columnMoveErrors,
	Game* game, ExitCodes* exitStatus, int* eofFlag);

/* Takes in the strtol errors generated by calls to obtain the specific row
 * and column moves, and the game representation. Executes the move calculated
 * by game_move. */
void play_move(char* rowMoveErrors, char* columnMoveErrors, Game* game);

/* Takes in the human move (for error handling), the strtol errors generated
 * by calls to obtain the specific row and column moves (also for error
 * handling), and the game representation. Handles Type 0 moves. Does NOT
 * print the new move. */
void type_zero_move(char** move, char** rowMoveErrors,
	char** columnMoveErrors, Game* game);

/* Takes in the game representation, the current opponent, the human move (for
 * error handling), and the strtol errors generated by calls to obtain the
 * specific row and column moves (also for error handling). Entry point for
 * all type one moves. Selects the appropriate type one move to play.
 * NOTE does not execute said move. */
void type_one_move(Game* game, char opponent, char** move,
	char** rowMoveErrors, char** columnMoveErrors);

/* Takes in the game representation, the current opponent, the human move (for
 * error handling), and the strtol errors generated by calls to obtain the
 * specific row and column moves (also for error handling). Checks if there
 * exists a move that pushes cells down such that the opponent's score is
 * lowered. Returns 1 if such a move is found, returns 0 otherwise.
 * NOTE: does not execute said move even if such a move is found. */
int type_one_push_down(Game* game, char opponent, char** move,
	char** rowMoveErrors, char** columnMoveErrors);

/* Takes in the game representation, the current opponent, the human move (for
 * error handling), and the strtol errors generated by calls to obtain the
 * specific row and column moves (also for error handling). Checks if there
 * exists a move that pushes cells left such that the opponent's score is
 * lowered. Returns 1 if such a move is found, returns 0 otherwise.
 * NOTE: does not execute said move even if such a move is found. */
int type_one_push_left(Game* game, char opponent, char** move,
	char** rowMoveErrors, char** columnMoveErrors);

/* Takes in the game representation, the current opponent, the human move (for
 * error handling), and the strtol errors generated by calls to obtain the
 * specific row and column moves (also for error handling). Checks if there
 * exists a move that pushes cells up such that the opponent's score is
 * lowered. Returns 1 if such a move is found, returns 0 otherwise.
 * NOTE: does not execute said move even if such a move is found. */
int type_one_push_up(Game* game, char opponent, char** move,
	char** rowMoveErrors, char** columnMoveErrors);

/* Takes in the game representation, the current opponent, the human move (for
 * error handling), and the strtol errors generated by calls to obtain the
 * specific row and column moves (also for error handling). Checks if there
 * exists a move that pushes cells right such that the opponent's score is
 * lowered. Returns 1 if such a move is found, returns 0 otherwise.
 * NOTE: does not execute said move even if such a move is found. */
int type_one_push_right(Game* game, char opponent, char** move,
	char** rowMoveErrors, char** columnMoveErrors);

/* Takes in the game representation, the human move (for error handling), and
 * the strtol errors generated by calls to obtain the specific row and column
 * moves (also for error handling). After checking the current scores of both
 * players, this function searches the board for the highest value cell. If
 * the scores are currently tied, only the first highest value cell that is
 * found is selected. NOTE: does not execute the move that is found. */
void type_one_highest_cell(Game* game, char** move, char** rowMoveErrors,
	char** columnMoveErrors);

/* Takes in the human move, the game representation, the strtol errors
 * generated by calls to obtain the specific row and column moves, and a flag
 * to check for EOF found in invalid places (e.g. when processing a valid
 * human move that ends in EOF). Ensures no leading or trailing spaces, no
 * invalid chars, no leading or trailing tabs, no empty moves, also ensure
 * move isn't save move, as saves should allow spaces in save file name. Also
 * forms as entry point for saving, and processes the specific row and column
 * moves. */
void human_move(char** move, Game* game, char** rowMoveErrors,
	char** columnMoveErrors, int* eofFlag);

/* Takes in score values for players O and X, and the game representation.
 * Calculates the current scores for players O and X. */
void current_score_calc(int* scoreO, int* scoreX, Game* game);

/* Takes in the game representation and selects the appropriate pushing cells
 * move to play, and ensures pushing move rules are met. */
void push_move(Game* game);

/* Takes in the game representation, a counter for the number of empty cells
 * in a given column, and an iterator to iterate through a column. This
 * function handles pushing cells up, and ensures pushing move rules are
 * met. */
void push_up(Game* game, int emptyCellCounter, int r);

/* Takes in the game representation, a counter for the number of empty cells
 * in a given column, and an iterator to iterate through a column. This
 * function handles pushing cells down, and ensures pushing move rules are
 * met. */
void push_down(Game* game, int emptyCellCounter, int r);

/* Takes in the game representation, a counter for the number of empty cells
 * in a given row, and an iterator to iterate through a row. This function
 * handles pushing cells left, and ensures pushing move rules are met. */
void push_left(Game* game, int emptyCellCounter, int c);

/* Takes in the game representation, a counter for the number of empty cells
 * in a given row, and an iterator to iterate through a row. This function
 * handles pushing cells right, and ensures pushing move rules are met. */
void push_right(Game* game, int emptyCellCounter, int c);

/* Takes in the game representation, the strtol errors generated by calls to
 * obtain row and column moves (for error handling), and the overall move
 * (also for error handling). This function saves the game by writing to a
 * save file with the given information from the game representation. */
void save_game(char** rowMoveErrors, char** columnMoveErrors, char** move,
	Game* game);

/* Takes in the game representation, the line from the save file that shows
 * the board dimensions, and the save file itself. Handles calculating and
 * displaying the game winner(s), and handles all free's and file closing. */
void game_over(Game* game, char* rowsAndColumns, FILE* gameFile);

/* Takes in the game representation and frees the board contents, the board
 * itself, and the game representation itself (as these were malloc'd). */
void game_free_memory(Game* game);
